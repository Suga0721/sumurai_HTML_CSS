<?php
//***************************** 
// ユーザーからの入力を受け付ける
//***************************** 
function input_user(&$users_word){

    $line = fgets(STDIN);
    $line = trim($line);
    var_dump($line);
    $users_word = $line;
}

//***************************** 
// その入力された内容を保存する     //例外処理(エラー処理)を使用している、(try、catch、throw)
//***************************** 
function save_input($users_word){
    $file_num = false;　//「そもそも最初はファイルが開かれていない」と$file_num = false;　で定義している。ファイルが開けなかった場合→$file_numにfalseが代入され、適用。
    try {　　　　　　　　　　　　　//$file_num = false;をtryの中に入れてしまうとfinallyブロックの中から見えなくなるからtryの外で定義している。
        　　　　　　　　　　　　　//finallyブロックでの処理に使いたいという理由もある

        //ファイル開く                      //try・catchと続けてfinallyと書くことで、tryブロックで例外が発生しても・しなくてもfinllyブロックで囲われた処理が行われます。

        $file_num = fopen ("sample1.txt",'w');　//ファイルが開けた場合、$file_numにfopen ("sample1.txt",'w')が代入され適用。
        if ($file_num === false) {
            throw new Exception("ファイルを開けませんでした"); //throw new Exeption()で例外を投げるという意味
        }

        //ファイルに書きこむ
        $bytes_written = fwrite($file_num ,$users_word);  //fwrite()関数が失敗するとfalseを返してきてそれが$bytes_writtenに代入されます。
        if ($bytes_written === false) {                   //なので、その直後のif文でその値を調べることで、fwrite()関数が成功したかどうかを調べることができるわけです。
            // 失敗した時の処理
            throw new Exception("ファイル書き込みに失敗しました"); //throw new Exeption()で例外を投げるという意味
        }

    } finally {   //finally　　→例外が発生するしないに関係なく、必ず実行。
        // ファイルが開かれていたら閉じる
        if ($file_num !== false) {　　//「!==」の等号や不等号は、値と「データ型」まで含めた完全一致か不完全一致かを判定します。
            fclose($file_num);        //  !=　の場合は値のみを比較している
        }
    }
}
　　　　　　　　　　　　　　　　　　　  //tryブロックで例外が発生する可能性がある処理を囲んでいる

try {                   　　　　　//41行目~50行目をtryで囲むことで51行目のcatchが機能する仕組みになっている
    $users_word =""; 　　　　　　 //tryで囲まれたサブルーチン呼び出しのどこかで例外が発生した場合、
                                //そのtryに続くcatchがそれを拾う、という仕組みになっています。
　　　　　　　　　　　　　　　　　　
    // ユーザーからの入力を受け付ける
    input_user($users_word);
    var_dump($users_word);

    // その入力された内容を保存する
    save_input($users_word);

} catch (Exception $e) {   　　　　//catch(Exception $e) {   } // { }の中で例外が発生した場合の処理を実施
    echo $e->getMessage()."\n"; //$e->getMessage()で例外メッセージを取得し表示しています。つまり、throw new Exeption() の()の中の文字が表示される
                                //  " -> " の意味はアロー演算子の事　左辺から右辺を取り出す演算子 
  }


  //ユーザーから入力した文字がカタカナ入力でしか、文字列として認識しなかった理由

  //php.iniで(php.iniはxamppのhtdocsのフォルダの中にある)がdefault_charset = "UTF-8"と設定されていたから
  //そのため　default_charset = "UTF-8"　から　default_charset = "SJIS-WIN"　に書き直さないといけない
  //
  //※書き直す方法※　
  //php.ini(xamppのhtdocsのフォルダの中にある)をメモ帳で開き→default_charset = "UTF-8"　から　default_charset = "SJIS-WIN"
  //に書き直せばOK！　確認後はすぐに　"UTF-8" に戻すこと　メモ帳内で ctrl+f　を押すとすぐに検索したいワードが出てきて検索が早くなる。
    //
  //インストラクターから
  //コマンドラインプログラムとしてPHPプログラムを動作させ、その際にコマンドプロンプトから日本語を入力した場合に正しく日本語が表示される
 //ことが重要ならば必要な設定ですが、「Webアプリケーションの開発を学び作成して行く」ことを重視するなら
 //「何の意味もない（それどころかむしろ邪魔になる）」設定だからです。なので、今回のことが確認できたらすぐに元に戻すこと。
  //日本語をめぐるIT事情にはまだこうした爆弾がありますが、UTF-8でどうにかなる世界だけ相手にしていればひとまずこのような不毛な問題にはぶち当たらずに済みます。
  //
  //
  //変数は一つだけでなく、複数の値を代入できる
　//そもそも変数はデータの入れ物に過ぎません。
　//はじめある値を入れていたが、都合が変わってほかの値を入れたくなるということはよくあります。
　//それに、それができないなら不便すぎます。
　//たとえば今回の場合は、初めにfalseを入れておく（＝ファイルが開けていない状態を意味するインジケーターとして使う）
　//fopen()が成功したら値をfopen()の戻り値のfalse以外の値に書き換えることで、「ファイルが上手く開けた」ことを意味するインジケーターになる

　　//このように、

　　//開けなかった→false
　　//開けた→false以外

　　//と値を変更させられるからこそ、34行目のfinallyブロック内での
　　//「必要に応じて閉じる」
　　//ということが実現できるのです。
  //
  //

